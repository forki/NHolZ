<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Il modulo Dltree
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A porting in F# of the "Original OCaml version of HOL Zero" by Mark Adams"/>
    <meta name="author" content="Domenico Masini"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/NHolZ/content/style.css" />
    <script type="text/javascript" src="/NHolZ/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://github.com/domasin/NHolZ">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/NHolZ/index.html">NHolZ</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1><a name="Il-modulo-Dltree" class="anchor" href="#Il-modulo-Dltree">Il modulo Dltree</a></h1>

<ol>
<li>Introduzione agli Alberi AA</li>
<li>Il datatype dltree</li>
<li>Operazioni base sui sotto alberi</li>
</ol>

<h2><a name="Introduzione-agli-Alberi-AA" class="anchor" href="#Introduzione-agli-Alberi-AA">Introduzione agli Alberi AA</a></h2>

<p>Il modulo dltree implementa il datatype e le funzioni per la gestione di 
<em>alberi AA</em> (chiamati anche alberi di Anderson). Si tratta di <em>alberi 
binari auto-bilanciati</em> che memorizzano informazioni su nodi ordinati 
in base a un indice e che permettono una ricerca efficiente.</p>

<p>Con bilanciati s'intende che si cerca di mantenere simile la 
profondita' dei vari rami nell'albero e in particolare negli alberi AA 
la massima distanza dalla radice a una foglia non e' piu' grande del 
doppio della distanza minima: il ramo piu' lungo non e' comunque piu' 
lungo del doppio del ramo piu' corto. Questa proprieta', si ottiene 
garantendo la cosiddetta <em>invariante AA</em>, e permette di implementare 
operazioni di ricerca, inserimento e cancellazione in questi alberi 
con una complessita' di tempo spazio che nel peggiore dei casi e' pari 
a O(log n).</p>

<p>Con <em>invariante AA</em> si intendono quattro aspetti che devono essere 
mantenuti negli alberi ad ogni operazione eseguita su di essi:</p>

<ol>
<li>il livello di ogni foglia deve essere 0;</li>
<li>il livello di ogni nodo sul ramo sinistro deve essere uguale a quello del suo padre meno uno.</li>
<li>il livello di ogni nodo sul ramo destro deve essere uguale a quello del suo padre o a quello del suo padre meno uno;</li>
<li>il livello di ogni nodo sul ramo piu' a destra nell'albero deve essere minore di quello dei suoi nonni.</li>
</ol>

<p>In questo modo il livello rappresenta la distanza dal nodo alla foglia piu' a 
sinistra discendente dal nodo, e un limite superiore di meta' della 
distanza dal nodo alla sua foglia discendente piu' a destra. Cosi' il 
livello e' un limite superiore di meta' della profonodita' dell'albero, ed e' 
anche un limite superiore per la differenza tra le profondita' delle foglie 
piu' profonde e di quelle meno profonde.</p>

<p>Le operazioni di inserimento e cancellazione preservano l'invariante AA 
applicando una combinazione di due operazioni di ribilanciamento - <code>skew</code> 
e <code>split</code> - una volta che un elemento e' stato inserito/cancellato. <code>skew</code> e 
<code>split</code> hanno entrambe una complessita' tempo/spazio O(1), e il numero di 
nodi su cui hanno bisogno di operare per un inserimento o una cancellazione e' al 
massimo O(log n), assicurando cosi' che l'inserimento e la cancellazione 
siano O(log n). La particolare combinazione di <code>skew</code> e <code>split</code> impiegata 
dipende dal fatto che sia stata eseguita una cancellazione oppure un 
inserimento.</p>

<p>Si noti che in un albero di ricerca binario classico per assicurare una corretta 
funzionalita' (cioe' che le voci possano essere cercate in base agli inserimenti e alle 
cancellazioni che sono avvenute), e' sufficiente che le operazioni di inserimento e 
cancellazione preservino un corretto ordinamento rispetto alla relazione di <em>&lt;</em>. 
In altre parole, l'invariante AA e' puramente per question di efficienza, e non aggiunge 
nulla alla correttezza. Si noti inoltre che le due operazioni di ribilanciamento preservano 
tutte un corretto ordinamento.</p>

<h2><a name="Il-datatype-dltree" class="anchor" href="#Il-datatype-dltree">Il datatype dltree</a></h2>

<p>Il datatype <code>dltree</code> e' la nostra specifica implementazione degli alberi AA per il 
nostro sistema: un datatype di albero di ricerca binario, dove ad 
ogni nodo sono mantenuti un indice e un elemento (una coppia in questo caso per l'uso 
specifico che sara' fatto di questra struttura nel sistema), e le foglie non hanno 
alcuna informazione. Il confronto tra indici e' fatto usando la relazione 
di oridinamento totale polimorfica '(&lt;)'. Ogni nodo mantiene anche un 
intero per il suo livello AA, per poter mantenere l'invariante AA. Si noti 
che non c'e' alcuna necessita' che le foglie mantengano il proprio livello 
perche' esso e' sempre 0.</p>

<p>Ogni nodo (<code>Node</code>) nell'albero e' una tupla il cui primo elemento <code>int</code> e' l'intero che 
rappresenta il livello del nodo nell'albero; il secondo elemento <code>('a * 'b)</code> e' una 
coppia: l'informazione che vogliamo immagazzinare nel nodo (il motivo 
per cui viene immagazzinata una coppia dipende dal particolare uso che 
vogliamo fare del dltree nel sistema); i due elmenti successivi <code>dltree&lt;'a,'b&gt;</code> sono 
rispettivamente il sottoalbero sinistro e destro del nodo. Le foglie (<code>Leaf</code>) non mantengono 
alcuna informazione e indicano solo la terminazione dei rami:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="t">dltree&#39;</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span>,<span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="o">=</span>
    | <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="p">Node&#39;</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="t">int</span> <span class="o">*</span> (<span class="o">&#39;</span><span class="i">a</span> <span class="o">*</span> <span class="o">&#39;</span><span class="i">b</span>) <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 5)" onmouseover="showTip(event, 'fs2', 5)" class="t">dltree&#39;</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span>,<span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 6)" onmouseover="showTip(event, 'fs2', 6)" class="t">dltree&#39;</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span>,<span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
    | <span onmouseout="hideTip(event, 'fs5', 7)" onmouseover="showTip(event, 'fs5', 7)" class="p">Leaf&#39;</span>
</code></pre></td>
</tr>
</table>

<p>Con la funzione <code>dltree_empty</code> possiamo creare un albero vuoto che conterra' inzialmente 
solo una foglia e che possiamo usare come contenitore inziale vuoto a cui poter aggiungere 
informazioni:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs6', 8)" onmouseover="showTip(event, 'fs6', 8)" class="i">dltree_empty&#39;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="p">Leaf</span>
</code></pre></td>
</tr>
</table>

<p>Con la funzione <code>dltree_elems</code> possiamo estrarre l'informazione mantenuta in un dato albero di ricerca 
binario sotto forma di una lista di associazione in cui gli elementi dell'albero compariranno secondo il 
loro indice all'interno dell'albero in una lettura da sinistra a destra:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs8', 10)" onmouseover="showTip(event, 'fs8', 10)" class="f">dltree_elems&#39;</span> <span onmouseout="hideTip(event, 'fs9', 11)" onmouseover="showTip(event, 'fs9', 11)" class="i">tr</span> <span class="o">=</span> 
    <span class="c">/// Funzione tail-ricorsiva a supporto della definizione di dltree_elems</span>
    <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="f">dltree_elems0&#39;</span> <span onmouseout="hideTip(event, 'fs11', 13)" onmouseover="showTip(event, 'fs11', 13)" class="i">tr</span> <span onmouseout="hideTip(event, 'fs12', 14)" onmouseover="showTip(event, 'fs12', 14)" class="i">xys0</span> <span class="o">=</span>
        <span class="k">match</span> <span onmouseout="hideTip(event, 'fs11', 15)" onmouseover="showTip(event, 'fs11', 15)" class="i">tr</span> <span class="k">with</span>
        | <span onmouseout="hideTip(event, 'fs3', 16)" onmouseover="showTip(event, 'fs3', 16)" class="p">Node&#39;</span> (_,<span onmouseout="hideTip(event, 'fs13', 17)" onmouseover="showTip(event, 'fs13', 17)" class="i">xy</span>,<span onmouseout="hideTip(event, 'fs14', 18)" onmouseover="showTip(event, 'fs14', 18)" class="i">tr1</span>,<span onmouseout="hideTip(event, 'fs15', 19)" onmouseover="showTip(event, 'fs15', 19)" class="i">tr2</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs10', 20)" onmouseover="showTip(event, 'fs10', 20)" class="f">dltree_elems0&#39;</span> <span onmouseout="hideTip(event, 'fs14', 21)" onmouseover="showTip(event, 'fs14', 21)" class="i">tr1</span> (<span onmouseout="hideTip(event, 'fs13', 22)" onmouseover="showTip(event, 'fs13', 22)" class="i">xy</span><span class="o">::</span>(<span onmouseout="hideTip(event, 'fs10', 23)" onmouseover="showTip(event, 'fs10', 23)" class="f">dltree_elems0&#39;</span> <span onmouseout="hideTip(event, 'fs15', 24)" onmouseover="showTip(event, 'fs15', 24)" class="i">tr2</span> <span onmouseout="hideTip(event, 'fs12', 25)" onmouseover="showTip(event, 'fs12', 25)" class="i">xys0</span>))
        | <span onmouseout="hideTip(event, 'fs5', 26)" onmouseover="showTip(event, 'fs5', 26)" class="p">Leaf&#39;</span>                <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs12', 27)" onmouseover="showTip(event, 'fs12', 27)" class="i">xys0</span>
    <span onmouseout="hideTip(event, 'fs10', 28)" onmouseover="showTip(event, 'fs10', 28)" class="f">dltree_elems0&#39;</span> <span onmouseout="hideTip(event, 'fs11', 29)" onmouseover="showTip(event, 'fs11', 29)" class="i">tr</span> []
</code></pre></td>
</tr>
</table>

<p>Per capirne lo scopo, creiamo ad esempio un albero vuoto e inseriamo qualche informazione: 
ad esempio cinque coppie di stringhe (si notino di passaggio gli indici associati a ciascuna coppia 
inserita nell'albero). Per farlo useremo la funzione <code>dltree_insert</code> che e' spiegata 
piu' avanti:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 30)" onmouseover="showTip(event, 'fs16', 30)" class="i">tr</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs17', 31)" onmouseover="showTip(event, 'fs17', 31)" class="i">dltree_empty</span>;;
<span class="c">// - val tr : dltree&lt;&#39;a,&#39;b&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 32)" onmouseover="showTip(event, 'fs18', 32)" class="i">tr1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 33)" onmouseover="showTip(event, 'fs19', 33)" class="f">dltree_insert</span> (<span class="s">&quot;a&quot;</span>,<span class="s">&quot;b&quot;</span>) <span onmouseout="hideTip(event, 'fs16', 34)" onmouseover="showTip(event, 'fs16', 34)" class="i">tr</span>;;
<span class="c">// - val tr1 : dltree&lt;string,string&gt; = Node (1,(&quot;a&quot;, &quot;b&quot;),Leaf,Leaf)</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 35)" onmouseover="showTip(event, 'fs20', 35)" class="i">tr2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 36)" onmouseover="showTip(event, 'fs19', 36)" class="f">dltree_insert</span> (<span class="s">&quot;c&quot;</span>,<span class="s">&quot;d&quot;</span>) <span onmouseout="hideTip(event, 'fs18', 37)" onmouseover="showTip(event, 'fs18', 37)" class="i">tr1</span>;;
<span class="c">// - val tr2 : dltree&lt;string,string&gt; =</span>
<span class="c">//    Node (1,(&quot;a&quot;, &quot;b&quot;),Leaf,Node (1,(&quot;c&quot;, &quot;d&quot;),Leaf,Leaf))</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 38)" onmouseover="showTip(event, 'fs21', 38)" class="i">tr3</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 39)" onmouseover="showTip(event, 'fs19', 39)" class="f">dltree_insert</span> (<span class="s">&quot;e&quot;</span>,<span class="s">&quot;e&quot;</span>) <span onmouseout="hideTip(event, 'fs20', 40)" onmouseover="showTip(event, 'fs20', 40)" class="i">tr2</span>;;
<span class="c">// - val tr3 : dltree&lt;string,string&gt; =</span>
<span class="c">//     Node</span>
<span class="c">//       (2,(&quot;c&quot;, &quot;d&quot;),Node (1,(&quot;a&quot;, &quot;b&quot;),Leaf,Leaf),Node (1,(&quot;e&quot;, &quot;e&quot;),Leaf,Leaf))</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 41)" onmouseover="showTip(event, 'fs22', 41)" class="i">tr4</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 42)" onmouseover="showTip(event, 'fs19', 42)" class="f">dltree_insert</span> (<span class="s">&quot;w&quot;</span>,<span class="s">&quot;z&quot;</span>) <span onmouseout="hideTip(event, 'fs21', 43)" onmouseover="showTip(event, 'fs21', 43)" class="i">tr3</span>;;
<span class="c">// - val tr4 : dltree&lt;string,string&gt; =</span>
<span class="c">//     Node</span>
<span class="c">//       (2,(&quot;c&quot;, &quot;d&quot;),Node (1,(&quot;a&quot;, &quot;b&quot;),Leaf,Leaf),</span>
<span class="c">//        Node (1,(&quot;e&quot;, &quot;e&quot;),Leaf,Node (1,(&quot;w&quot;, &quot;z&quot;),Leaf,Leaf)))</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 44)" onmouseover="showTip(event, 'fs23', 44)" class="i">tr5</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 45)" onmouseover="showTip(event, 'fs19', 45)" class="f">dltree_insert</span> (<span class="s">&quot;o&quot;</span>,<span class="s">&quot;e&quot;</span>) <span onmouseout="hideTip(event, 'fs22', 46)" onmouseover="showTip(event, 'fs22', 46)" class="i">tr4</span>;;
<span class="c">// - val tr5 : dltree&lt;string,string&gt; =</span>
<span class="c">//     Node</span>
<span class="c">//       (2,(&quot;c&quot;, &quot;d&quot;),Node (1,(&quot;a&quot;, &quot;b&quot;),Leaf,Leaf),</span>
<span class="c">//        Node</span>
<span class="c">//          (2,(&quot;o&quot;, &quot;e&quot;),Node (1,(&quot;e&quot;, &quot;e&quot;),Leaf,Leaf),</span>
<span class="c">//           Node (1,(&quot;w&quot;, &quot;z&quot;),Leaf,Leaf)))</span>
<span onmouseout="hideTip(event, 'fs24', 47)" onmouseover="showTip(event, 'fs24', 47)" class="f">dltree_elems</span> <span onmouseout="hideTip(event, 'fs23', 48)" onmouseover="showTip(event, 'fs23', 48)" class="i">tr5</span>;;
<span class="c">// - val it : (string * string) list = [(&quot;a&quot;, &quot;b&quot;); (&quot;c&quot;, &quot;d&quot;); (&quot;e&quot;, &quot;e&quot;); (&quot;o&quot;, &quot;e&quot;); (&quot;w&quot;, &quot;z&quot;)]</span>
</code></pre></td>
</tr>
</table>

<p>(
<strong>Nota</strong>: negli esempi, quando viene data l'implementazione delle funzioni e dei datatype, 
come nei blocchi di codice piu' sopra, ai nomi delle funzioni sono aggiunti degli apici per 
distinguerle dalle implentazioni del programma. Quando si danno, invece,  gli esempi del 
funzionamento delle funzioni, come nel blocco precedente, sono usate dirattamente le 
funzioni del programma (senza apici). )</p>

<p>Si noti la struttura dell'albero creato e l'ordine degli elementi estratti:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//     (c,d)[2]      </span>
<span class="c">//    /        \     </span>
<span class="c">// (a,b)[1]     (o,e)[2] </span>
<span class="c">//             /       \   </span>
<span class="c">//         (e,e)[1]   (w,z)[1]</span>
<span class="c">// </span>
<span class="c">// [(&quot;a&quot;, &quot;b&quot;); (&quot;c&quot;, &quot;d&quot;); (&quot;e&quot;, &quot;e&quot;); (&quot;o&quot;, &quot;e&quot;); (&quot;w&quot;, &quot;z&quot;)]</span>
<span onmouseout="hideTip(event, 'fs25', 49)" onmouseover="showTip(event, 'fs25', 49)" class="p">Node</span>
    (<span class="n">2</span>,(<span class="s">&quot;c&quot;</span>, <span class="s">&quot;d&quot;</span>),
        <span onmouseout="hideTip(event, 'fs25', 50)" onmouseover="showTip(event, 'fs25', 50)" class="p">Node</span> (<span class="n">1</span>,(<span class="s">&quot;a&quot;</span>, <span class="s">&quot;b&quot;</span>),<span onmouseout="hideTip(event, 'fs7', 51)" onmouseover="showTip(event, 'fs7', 51)" class="p">Leaf</span>,<span onmouseout="hideTip(event, 'fs7', 52)" onmouseover="showTip(event, 'fs7', 52)" class="p">Leaf</span>),
        <span onmouseout="hideTip(event, 'fs25', 53)" onmouseover="showTip(event, 'fs25', 53)" class="p">Node</span> 
           (<span class="n">2</span>,(<span class="s">&quot;o&quot;</span>, <span class="s">&quot;e&quot;</span>),
               <span onmouseout="hideTip(event, 'fs25', 54)" onmouseover="showTip(event, 'fs25', 54)" class="p">Node</span> (<span class="n">1</span>,(<span class="s">&quot;e&quot;</span>, <span class="s">&quot;e&quot;</span>),<span onmouseout="hideTip(event, 'fs7', 55)" onmouseover="showTip(event, 'fs7', 55)" class="p">Leaf</span>,<span onmouseout="hideTip(event, 'fs7', 56)" onmouseover="showTip(event, 'fs7', 56)" class="p">Leaf</span>),
               <span onmouseout="hideTip(event, 'fs25', 57)" onmouseover="showTip(event, 'fs25', 57)" class="p">Node</span> (<span class="n">1</span>,(<span class="s">&quot;w&quot;</span>, <span class="s">&quot;z&quot;</span>),<span onmouseout="hideTip(event, 'fs7', 58)" onmouseover="showTip(event, 'fs7', 58)" class="p">Leaf</span>,<span onmouseout="hideTip(event, 'fs7', 59)" onmouseover="showTip(event, 'fs7', 59)" class="p">Leaf</span>)
           )
    )
</code></pre></td>
</tr>
</table>

<h2><a name="Operazioni-base-sui-sotto-alberi" class="anchor" href="#Operazioni-base-sui-sotto-alberi">Operazioni base sui sotto alberi</a></h2>

<p>Questa sezione del modulo implementa le funzioni base di gestione dell'albero tra cui 
l'inserimento, la cancellazione, le operazioni di <code>skew</code> e <code>split</code> per rigenerare gli 
indici e la struttura dell'albero in modo da garantire l'invariante AA in seguito agli 
inserimenti e cancellazione effettuati, e l'operazione di ricerca all'interno 
dell'albero.</p>

<p>Sono innanzitutto definite alcune funzioni di supproto.</p>

<p>La funzione <code>level</code> restituisce il livello dell'albero:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 60)" onmouseover="showTip(event, 'fs26', 60)" class="f">level&#39;</span> <span onmouseout="hideTip(event, 'fs9', 61)" onmouseover="showTip(event, 'fs9', 61)" class="i">tr</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs9', 62)" onmouseover="showTip(event, 'fs9', 62)" class="i">tr</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs3', 63)" onmouseover="showTip(event, 'fs3', 63)" class="p">Node&#39;</span> (<span onmouseout="hideTip(event, 'fs27', 64)" onmouseover="showTip(event, 'fs27', 64)" class="i">l</span>,_,_,_) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs27', 65)" onmouseover="showTip(event, 'fs27', 65)" class="i">l</span>
    | <span onmouseout="hideTip(event, 'fs5', 66)" onmouseover="showTip(event, 'fs5', 66)" class="p">Leaf&#39;</span>           <span class="k">-&gt;</span> <span class="n">0</span>
</code></pre></td>
</tr>
</table>

<p>Ad esempio il livello dell'abero che abbiamo appena costruito di sopra <code>tr5</code> e' 2:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs28', 67)" onmouseover="showTip(event, 'fs28', 67)" class="f">level</span> <span onmouseout="hideTip(event, 'fs23', 68)" onmouseover="showTip(event, 'fs23', 68)" class="i">tr5</span>;;
<span class="c">// - val it : int = 2</span>
</code></pre></td>
</tr>
</table>

<p>La funzione <code>rightmost_elem</code> restituisce l'informazione mantenuta nel nodo piu' 
a destra dell'albero ed e' usata per applicare le operazioni di trasformazione <code>skew</code> e 
<code>split</code> in seguito a una cancellazione <code>dltree_delete</code> descritta piu' sotto. Oltre all'albero 
e' passata in input un argomento nel caso in cui l'albero contenga solo una foglia:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">/// Restituisce come una coppia il nodo piu&#39; a destra nell&#39;albero. </span>
<span class="c">/// Se l&#39;albero e&#39; solo una Leaf, allora non ha nodi e in questo </span>
<span class="c">/// caso la funzione restituisce solo la coppia in input.</span>
<span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fs29', 69)" onmouseover="showTip(event, 'fs29', 69)" class="f">rightmost_elem&#39;</span> <span onmouseout="hideTip(event, 'fs30', 70)" onmouseover="showTip(event, 'fs30', 70)" class="i">xy0</span> <span onmouseout="hideTip(event, 'fs31', 71)" onmouseover="showTip(event, 'fs31', 71)" class="i">tr</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs31', 72)" onmouseover="showTip(event, 'fs31', 72)" class="i">tr</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs25', 73)" onmouseover="showTip(event, 'fs25', 73)" class="p">Node</span> (_,<span onmouseout="hideTip(event, 'fs32', 74)" onmouseover="showTip(event, 'fs32', 74)" class="i">xy</span>,_,<span onmouseout="hideTip(event, 'fs33', 75)" onmouseover="showTip(event, 'fs33', 75)" class="i">tr2</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs29', 76)" onmouseover="showTip(event, 'fs29', 76)" class="f">rightmost_elem&#39;</span> <span onmouseout="hideTip(event, 'fs32', 77)" onmouseover="showTip(event, 'fs32', 77)" class="i">xy</span> <span onmouseout="hideTip(event, 'fs33', 78)" onmouseover="showTip(event, 'fs33', 78)" class="i">tr2</span>
    | <span onmouseout="hideTip(event, 'fs7', 79)" onmouseover="showTip(event, 'fs7', 79)" class="p">Leaf</span>              <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs30', 80)" onmouseover="showTip(event, 'fs30', 80)" class="i">xy0</span>

<span onmouseout="hideTip(event, 'fs34', 81)" onmouseover="showTip(event, 'fs34', 81)" class="f">rightmost_elem</span> (<span class="s">&quot;&quot;</span>,<span class="s">&quot;&quot;</span>) <span onmouseout="hideTip(event, 'fs23', 82)" onmouseover="showTip(event, 'fs23', 82)" class="i">tr5</span>;;
<span class="c">// - val it : string * string = (&quot;w&quot;, &quot;z&quot;)</span>

<span onmouseout="hideTip(event, 'fs34', 83)" onmouseover="showTip(event, 'fs34', 83)" class="f">rightmost_elem</span> (<span class="s">&quot;&quot;</span>,<span class="s">&quot;&quot;</span>) <span onmouseout="hideTip(event, 'fs17', 84)" onmouseover="showTip(event, 'fs17', 84)" class="i">dltree_empty</span>;;
<span class="c">// - val it : string * string = (&quot;&quot;, &quot;&quot;)</span>
</code></pre></td>
</tr>
</table>

<p>La funzione <code>right_app</code> applica una funzione al primo nodo piu' a destra di 
un albero ed e' usata per applicare le operazioni di trasformazione <code>skew</code> e 
<code>split</code> in seguito a una cancellazione <code>dltree_delete</code> descritta piu' sotto:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs35', 85)" onmouseover="showTip(event, 'fs35', 85)" class="f">right_app&#39;</span> <span onmouseout="hideTip(event, 'fs36', 86)" onmouseover="showTip(event, 'fs36', 86)" class="f">f</span> <span onmouseout="hideTip(event, 'fs31', 87)" onmouseover="showTip(event, 'fs31', 87)" class="i">tr</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs31', 88)" onmouseover="showTip(event, 'fs31', 88)" class="i">tr</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs25', 89)" onmouseover="showTip(event, 'fs25', 89)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs27', 90)" onmouseover="showTip(event, 'fs27', 90)" class="i">l</span>,<span onmouseout="hideTip(event, 'fs32', 91)" onmouseover="showTip(event, 'fs32', 91)" class="i">xy</span>,<span onmouseout="hideTip(event, 'fs37', 92)" onmouseover="showTip(event, 'fs37', 92)" class="i">tr1</span>,<span onmouseout="hideTip(event, 'fs33', 93)" onmouseover="showTip(event, 'fs33', 93)" class="i">tr2</span>)   <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 94)" onmouseover="showTip(event, 'fs25', 94)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs27', 95)" onmouseover="showTip(event, 'fs27', 95)" class="i">l</span>, <span onmouseout="hideTip(event, 'fs32', 96)" onmouseover="showTip(event, 'fs32', 96)" class="i">xy</span>, <span onmouseout="hideTip(event, 'fs37', 97)" onmouseover="showTip(event, 'fs37', 97)" class="i">tr1</span>, <span onmouseout="hideTip(event, 'fs36', 98)" onmouseover="showTip(event, 'fs36', 98)" class="f">f</span> <span onmouseout="hideTip(event, 'fs33', 99)" onmouseover="showTip(event, 'fs33', 99)" class="i">tr2</span>)
    | _                     <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs31', 100)" onmouseover="showTip(event, 'fs31', 100)" class="i">tr</span>
</code></pre></td>
</tr>
</table>

<p>La funzione <code>decrease_level</code> decresce il livello della radice di un albero a 
un dato livello piu' basso. Se il livello dato e' maggiore o uguale al livello 
originario l'albero rimane invariato:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs38', 101)" onmouseover="showTip(event, 'fs38', 101)" class="f">decrease_level&#39;</span> <span onmouseout="hideTip(event, 'fs39', 102)" onmouseover="showTip(event, 'fs39', 102)" class="i">l&#39;</span> <span onmouseout="hideTip(event, 'fs31', 103)" onmouseover="showTip(event, 'fs31', 103)" class="i">tr</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs31', 104)" onmouseover="showTip(event, 'fs31', 104)" class="i">tr</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs25', 105)" onmouseover="showTip(event, 'fs25', 105)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs27', 106)" onmouseover="showTip(event, 'fs27', 106)" class="i">l</span>,<span onmouseout="hideTip(event, 'fs32', 107)" onmouseover="showTip(event, 'fs32', 107)" class="i">xy</span>,<span onmouseout="hideTip(event, 'fs37', 108)" onmouseover="showTip(event, 'fs37', 108)" class="i">tr1</span>,<span onmouseout="hideTip(event, 'fs33', 109)" onmouseover="showTip(event, 'fs33', 109)" class="i">tr2</span>) <span class="k">when</span> (<span onmouseout="hideTip(event, 'fs27', 110)" onmouseover="showTip(event, 'fs27', 110)" class="i">l</span> <span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs39', 111)" onmouseover="showTip(event, 'fs39', 111)" class="i">l&#39;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs25', 112)" onmouseover="showTip(event, 'fs25', 112)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs39', 113)" onmouseover="showTip(event, 'fs39', 113)" class="i">l&#39;</span>,<span onmouseout="hideTip(event, 'fs32', 114)" onmouseover="showTip(event, 'fs32', 114)" class="i">xy</span>,<span onmouseout="hideTip(event, 'fs37', 115)" onmouseover="showTip(event, 'fs37', 115)" class="i">tr1</span>,<span onmouseout="hideTip(event, 'fs33', 116)" onmouseover="showTip(event, 'fs33', 116)" class="i">tr2</span>)
    | _  <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs31', 117)" onmouseover="showTip(event, 'fs31', 117)" class="i">tr</span>
</code></pre></td>
</tr>
</table>

<p>Anche questa funzione e' usata per applicare le operazioni di trasformazione 
<code>skew</code> e <code>split</code> in seguito a una cancellazione <code>dltree_delete</code> descritta piu' 
sotto e non ha senso usarla al di fuori di questo contesto:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs40', 118)" onmouseover="showTip(event, 'fs40', 118)" class="f">decrease_level</span> <span class="n">1</span> <span onmouseout="hideTip(event, 'fs23', 119)" onmouseover="showTip(event, 'fs23', 119)" class="i">tr5</span>;;
<span class="c">// val it : dltree&lt;string,string&gt; =</span>
<span class="c">//   Node</span>
<span class="c">//     (1,(&quot;c&quot;, &quot;d&quot;),Node (1,(&quot;a&quot;, &quot;b&quot;),Leaf,Leaf),</span>
<span class="c">//      Node</span>
<span class="c">//        (2,(&quot;o&quot;, &quot;e&quot;),Node (1,(&quot;e&quot;, &quot;e&quot;),Leaf,Leaf),</span>
<span class="c">//         Node (1,(&quot;w&quot;, &quot;z&quot;),Leaf,Leaf)))</span>
</code></pre></td>
</tr>
</table>

<p>Si noti infatti che la radice ha indice 1 e l'albero non soddifa piu' l'invariante AA.</p>

<p>Vediamo ora le operazioni di trasformazione.</p>

<p>L'operazione di <code>skew</code> esegue una singola rotazione a destra ed e' usata per 
ribilanciare l'albero quando il ramo sinistro ha lo stesso livello del padre:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs41', 120)" onmouseover="showTip(event, 'fs41', 120)" class="f">skew&#39;</span> <span onmouseout="hideTip(event, 'fs31', 121)" onmouseover="showTip(event, 'fs31', 121)" class="i">tr</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs31', 122)" onmouseover="showTip(event, 'fs31', 122)" class="i">tr</span> <span class="k">with</span>
    <span onmouseout="hideTip(event, 'fs25', 123)" onmouseover="showTip(event, 'fs25', 123)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs27', 124)" onmouseover="showTip(event, 'fs27', 124)" class="i">l</span>, <span onmouseout="hideTip(event, 'fs32', 125)" onmouseover="showTip(event, 'fs32', 125)" class="i">xy</span>, <span onmouseout="hideTip(event, 'fs25', 126)" onmouseover="showTip(event, 'fs25', 126)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs42', 127)" onmouseover="showTip(event, 'fs42', 127)" class="i">l1</span>,<span onmouseout="hideTip(event, 'fs43', 128)" onmouseover="showTip(event, 'fs43', 128)" class="i">xy1</span>,<span onmouseout="hideTip(event, 'fs44', 129)" onmouseover="showTip(event, 'fs44', 129)" class="i">tr11</span>,<span onmouseout="hideTip(event, 'fs45', 130)" onmouseover="showTip(event, 'fs45', 130)" class="i">tr12</span>), <span onmouseout="hideTip(event, 'fs33', 131)" onmouseover="showTip(event, 'fs33', 131)" class="i">tr2</span>)
        <span class="k">-&gt;</span> <span class="k">if</span> (<span onmouseout="hideTip(event, 'fs42', 132)" onmouseover="showTip(event, 'fs42', 132)" class="i">l1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs27', 133)" onmouseover="showTip(event, 'fs27', 133)" class="i">l</span>)
            <span class="k">then</span> <span onmouseout="hideTip(event, 'fs25', 134)" onmouseover="showTip(event, 'fs25', 134)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs42', 135)" onmouseover="showTip(event, 'fs42', 135)" class="i">l1</span>, <span onmouseout="hideTip(event, 'fs43', 136)" onmouseover="showTip(event, 'fs43', 136)" class="i">xy1</span>, <span onmouseout="hideTip(event, 'fs44', 137)" onmouseover="showTip(event, 'fs44', 137)" class="i">tr11</span>, <span onmouseout="hideTip(event, 'fs25', 138)" onmouseover="showTip(event, 'fs25', 138)" class="p">Node</span> (<span onmouseout="hideTip(event, 'fs27', 139)" onmouseover="showTip(event, 'fs27', 139)" class="i">l</span>,<span onmouseout="hideTip(event, 'fs32', 140)" onmouseover="showTip(event, 'fs32', 140)" class="i">xy</span>,<span onmouseout="hideTip(event, 'fs45', 141)" onmouseover="showTip(event, 'fs45', 141)" class="i">tr12</span>,<span onmouseout="hideTip(event, 'fs33', 142)" onmouseover="showTip(event, 'fs33', 142)" class="i">tr2</span>))
            <span class="k">else</span> <span onmouseout="hideTip(event, 'fs31', 143)" onmouseover="showTip(event, 'fs31', 143)" class="i">tr</span>
    | _  <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs31', 144)" onmouseover="showTip(event, 'fs31', 144)" class="i">tr</span>
</code></pre></td>
</tr>
</table>

<p>Per vederne un esempio creiamo esplicitamente un albero che non soddisfa 
l'invariante AA in quanto il ramo sinistro ha lo stesso livello della 
radice e violando quindi il punto 2. della definizione di invariante AA 
data sopra:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
<span class="l">28: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs46', 145)" onmouseover="showTip(event, 'fs46', 145)" class="i">tr6</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs25', 146)" onmouseover="showTip(event, 'fs25', 146)" class="p">Node</span>
        (<span class="n">2</span>,(<span class="s">&quot;D&quot;</span>,<span class="n">0</span>),
            <span onmouseout="hideTip(event, 'fs25', 147)" onmouseover="showTip(event, 'fs25', 147)" class="p">Node</span> 
                (<span class="n">2</span>,(<span class="s">&quot;B&quot;</span>,<span class="n">0</span>),
                    <span onmouseout="hideTip(event, 'fs25', 148)" onmouseover="showTip(event, 'fs25', 148)" class="p">Node</span> (<span class="n">1</span>,(<span class="s">&quot;A&quot;</span>,<span class="n">0</span>),<span onmouseout="hideTip(event, 'fs7', 149)" onmouseover="showTip(event, 'fs7', 149)" class="p">Leaf</span>,<span onmouseout="hideTip(event, 'fs7', 150)" onmouseover="showTip(event, 'fs7', 150)" class="p">Leaf</span>),
                    <span onmouseout="hideTip(event, 'fs25', 151)" onmouseover="showTip(event, 'fs25', 151)" class="p">Node</span> (<span class="n">1</span>,(<span class="s">&quot;C&quot;</span>,<span class="n">0</span>),<span onmouseout="hideTip(event, 'fs7', 152)" onmouseover="showTip(event, 'fs7', 152)" class="p">Leaf</span>,<span onmouseout="hideTip(event, 'fs7', 153)" onmouseover="showTip(event, 'fs7', 153)" class="p">Leaf</span>)
                ),
            <span onmouseout="hideTip(event, 'fs25', 154)" onmouseover="showTip(event, 'fs25', 154)" class="p">Node</span> (<span class="n">1</span>,(<span class="s">&quot;E&quot;</span>,<span class="n">0</span>),<span onmouseout="hideTip(event, 'fs7', 155)" onmouseover="showTip(event, 'fs7', 155)" class="p">Leaf</span>,<span onmouseout="hideTip(event, 'fs7', 156)" onmouseover="showTip(event, 'fs7', 156)" class="p">Leaf</span>)
        )

<span class="c">//          (&quot;D&quot;,0)[2]                            (&quot;B&quot;,0)[2]</span>
<span class="c">//         /          \                             /       \</span>
<span class="c">//       (&quot;B&quot;,0)[2]  (&quot;E&quot;,0)[..]     --&gt;    (&quot;A&quot;,0)[..]  (&quot;D&quot;,0)[2]</span>
<span class="c">//      /         \                                        /   \</span>
<span class="c">//   (&quot;A&quot;,0)[..]  (&quot;C&quot;,0)[..]                     (&quot;C&quot;,0)[..]  (&quot;E&quot;,0)[..]</span>
<span class="c">//      </span>
<span onmouseout="hideTip(event, 'fs47', 157)" onmouseover="showTip(event, 'fs47', 157)" class="f">skew</span> <span onmouseout="hideTip(event, 'fs46', 158)" onmouseover="showTip(event, 'fs46', 158)" class="i">tr6</span>;;
<span class="c">// val it : dltree&lt;string,int&gt; =</span>
<span class="c">//   Node</span>
<span class="c">//     (2,(&quot;B&quot;, 0),</span>
<span class="c">//         Node (1,(&quot;A&quot;, 0),Leaf,Leaf),</span>
<span class="c">//         Node </span>
<span class="c">//             (2,(&quot;D&quot;, 0),</span>
<span class="c">//                 Node (1,(&quot;C&quot;, 0),Leaf,Leaf),</span>
<span class="c">//                 Node (1,(&quot;E&quot;, 0),Leaf,Leaf)</span>
<span class="c">//             )</span>
<span class="c">//         )</span>
</code></pre></td>
</tr>
</table>

<p>L'operazione ha creato un nuovo albero che contiene l'informazione originaria 
ma che in piu' ora soddisfa l'invariante AA. Si noti pero' che questo vale per 
questo caso particolare. L'operazione di per se' non ristabilisce l'invariante 
ma deve essere usata nelle situazioni opportune ed eventualmente in combinazione 
con l'operazione di <code>split</code>.</p>

<p>L'operazione di <code>split</code> esegue una singola rotazione a sinistra per ribilanciare 
quando il nodo piu' a destra ha lo stesso livello del suo nonno (violando quindi 
il punto 4. della definizione di invariante AA data sopra), e incrementa di uno 
il livello del nodo radice risultante.</p>

<div class="tip" id="fs1">namespace NHolZ</div>
<div class="tip" id="fs2">type dltree&#39;&lt;&#39;a,&#39;b&gt; =<br />&#160;&#160;| Node&#39; of int * (&#39;a * &#39;b) * dltree&#39;&lt;&#39;a,&#39;b&gt; * dltree&#39;&lt;&#39;a,&#39;b&gt;<br />&#160;&#160;| Leaf&#39;<br /><br />Full name: Dltree.dltree&#39;&lt;_,_&gt;</div>
<div class="tip" id="fs3">union case dltree&#39;.Node&#39;: int * (&#39;a * &#39;b) * dltree&#39;&lt;&#39;a,&#39;b&gt; * dltree&#39;&lt;&#39;a,&#39;b&gt; -&gt; dltree&#39;&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs4">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs5">union case dltree&#39;.Leaf&#39;: dltree&#39;&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs6">val dltree_empty&#39; : dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: Dltree.dltree_empty&#39;</div>
<div class="tip" id="fs7">union case dltree.Leaf: dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs8">val dltree_elems&#39; : tr:dltree&#39;&lt;&#39;a,&#39;b&gt; -&gt; (&#39;a * &#39;b) list<br /><br />Full name: Dltree.dltree_elems&#39;</div>
<div class="tip" id="fs9">val tr : dltree&#39;&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs10">val dltree_elems0&#39; : (dltree&#39;&lt;&#39;c,&#39;d&gt; -&gt; (&#39;c * &#39;d) list -&gt; (&#39;c * &#39;d) list)<br /><em><br /><br />&#160;Funzione tail-ricorsiva a supporto della definizione di dltree_elems</em></div>
<div class="tip" id="fs11">val tr : dltree&#39;&lt;&#39;c,&#39;d&gt;</div>
<div class="tip" id="fs12">val xys0 : (&#39;c * &#39;d) list</div>
<div class="tip" id="fs13">val xy : &#39;c * &#39;d</div>
<div class="tip" id="fs14">val tr1 : dltree&#39;&lt;&#39;c,&#39;d&gt;</div>
<div class="tip" id="fs15">val tr2 : dltree&#39;&lt;&#39;c,&#39;d&gt;</div>
<div class="tip" id="fs16">val tr : dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: Dltree.tr</div>
<div class="tip" id="fs17">val dltree_empty : dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: NHolZ.DLTree.dltree_empty</div>
<div class="tip" id="fs18">val tr1 : dltree&lt;string,string&gt;<br /><br />Full name: Dltree.tr1</div>
<div class="tip" id="fs19">val dltree_insert : &#39;a * &#39;b -&gt; tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt; (requires comparison)<br /><br />Full name: NHolZ.DLTree.dltree_insert</div>
<div class="tip" id="fs20">val tr2 : dltree&lt;string,string&gt;<br /><br />Full name: Dltree.tr2</div>
<div class="tip" id="fs21">val tr3 : dltree&lt;string,string&gt;<br /><br />Full name: Dltree.tr3</div>
<div class="tip" id="fs22">val tr4 : dltree&lt;string,string&gt;<br /><br />Full name: Dltree.tr4</div>
<div class="tip" id="fs23">val tr5 : dltree&lt;string,string&gt;<br /><br />Full name: Dltree.tr5</div>
<div class="tip" id="fs24">val dltree_elems : tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; (&#39;a * &#39;b) list<br /><br />Full name: NHolZ.DLTree.dltree_elems</div>
<div class="tip" id="fs25">union case dltree.Node: int * (&#39;a * &#39;b) * dltree&lt;&#39;a,&#39;b&gt; * dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs26">val level&#39; : tr:dltree&#39;&lt;&#39;a,&#39;b&gt; -&gt; int<br /><br />Full name: Dltree.level&#39;</div>
<div class="tip" id="fs27">val l : int</div>
<div class="tip" id="fs28">Multiple items<br />val level : tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; int<br /><br />Full name: NHolZ.DLTree.level<br /><br />--------------------<br />type level =<br />&#160;&#160;| Minimal<br />&#160;&#160;| Full<br /><br />Full name: NHolZ.Dmodes.level</div>
<div class="tip" id="fs29">val rightmost_elem&#39; : &#39;a * &#39;b -&gt; tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; &#39;a * &#39;b<br /><br />Full name: Dltree.rightmost_elem&#39;<br /><em><br /><br />&#160;Restituisce come una coppia il nodo piu&#39; a destra nell&#39;albero. <br />&#160;Se l&#39;albero e&#39; solo una Leaf, allora non ha nodi e in questo <br />&#160;caso la funzione restituisce solo la coppia in input.</em></div>
<div class="tip" id="fs30">val xy0 : &#39;a * &#39;b</div>
<div class="tip" id="fs31">val tr : dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs32">val xy : &#39;a * &#39;b</div>
<div class="tip" id="fs33">val tr2 : dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs34">val rightmost_elem : &#39;a * &#39;b -&gt; tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; &#39;a * &#39;b<br /><br />Full name: NHolZ.DLTree.rightmost_elem</div>
<div class="tip" id="fs35">val right_app&#39; : f:(dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;) -&gt; tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: Dltree.right_app&#39;</div>
<div class="tip" id="fs36">val f : (dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;)</div>
<div class="tip" id="fs37">val tr1 : dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs38">val decrease_level&#39; : l&#39;:int -&gt; tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: Dltree.decrease_level&#39;</div>
<div class="tip" id="fs39">val l&#39; : int</div>
<div class="tip" id="fs40">val decrease_level : l&#39;:int -&gt; tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: NHolZ.DLTree.decrease_level</div>
<div class="tip" id="fs41">val skew&#39; : tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: Dltree.skew&#39;</div>
<div class="tip" id="fs42">val l1 : int</div>
<div class="tip" id="fs43">val xy1 : &#39;a * &#39;b</div>
<div class="tip" id="fs44">val tr11 : dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs45">val tr12 : dltree&lt;&#39;a,&#39;b&gt;</div>
<div class="tip" id="fs46">val tr6 : dltree&lt;string,int&gt;<br /><br />Full name: Dltree.tr6</div>
<div class="tip" id="fs47">val skew : tr:dltree&lt;&#39;a,&#39;b&gt; -&gt; dltree&lt;&#39;a,&#39;b&gt;<br /><br />Full name: NHolZ.DLTree.skew</div>

        </div>
        <div class="span3">
          <img src="/NHolZ/img/logo.png" alt="F# Project" style="width:150px;margin:10px" />  
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">NHolZ</li>
            <li><a href="/NHolZ/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://nuget.org/packages/NHolZ">Get Library via NuGet</a></li>
            <li><a href="http://github.com/domasin/NHolZ">Source Code on GitHub</a></li>
            <li><a href="/NHolZ/license.html">License</a></li>
            <li><a href="/NHolZ/release-notes.html">Release Notes</a></li>
            
            <li class="nav-header">Getting started</li>
            <li><a href="/NHolZ/tutorial.html">Sample tutorial</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/NHolZ/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/domasin/NHolZ"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a>
  </body>
  </html>
